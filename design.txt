Matthew Richard
mricha56@jhu.edu

////////////////////// PART 1 ///////////////////////
We will name our multi-level hash data structure MLH_Map.

Constants:
HASH_RANGE = 5
NUM_ROWS = 8

Pseudo-declarations:

*** MLH_Map.h ***
template typename T
class MLH_Map
    
    class Node  <-- nested class
    public:
        int keys[HASH_RANGE]
        T* pvalues[HASH_RANGE]
        Node* children[HASH_RANGE]
        int size    <-- if leaf, # of entries in this node, else the sum of the sizes of its children
        
        void hard_destroy() <--calls 'delete' not only on this node, but on all the children and data pointed to by
                          this node.
        
        // helper methods
    
public:
    MLH_Map() <-- allocates root node, widths[0] = 1
    ~MLH_Map() <-- deletes all nodes, recursively

    int MLH_height() <-- starts from the highest widths[] index and returns first w/ nonzero entry
    int MLH_size() <-- returns size value of root node
    ostream &operator<<(ostream &output, const MLH_Map &m) <-- overload print
    void MLH_set_print_option(bool to) <-- determines whether to print keys and objects

    int MLH_insert(int key, T value) <-- 0 if failure, 1 if success. Inserts only if key isn't already present
    int MLH_delete(int key) <-- 0 if failure, 1 if success. 
    T MLH_get(int key) <-- NULL if not found

private:
    Node* root
    bool print_entries
    int widths[9]
    int steps

    bool is_stem(Node* n) <-- return n->size >= 5
    int index_in(int key, int array[5]) <-- helper method for seeing if a key is in a node. -1 if not there
    void expand(Node* n, int level) <-- expands a full node by rehashing into children.
    void collapse(Node* n, int level) <-- collapses into an available parent by rehashing into parent. 

    // our recursive helper methods to the main MLH operations (insert, delete, get). Insert, delete, and get
    // values in the subtree whose root is 'n'. Don't forget to copy the passed-in T value to static memory
    // in subtree_insert. 
    int subtree_insert(Node* n, int key, T &v)
    int subtree_delete(Node* n, int key)
    T* subtree_get(Node* n, int key)


*** Function details ***
~MLH_Map: deleting all nodes.
    Call root->hard_destroy().

Node::hard_destroy()
    If stem, call hard_destroy() on all non-null children.
    If leaf, delete at all data pointers, then delete the node itself.
        

void expand(Node* n, int level)
    Node* child    
    int new_children = 0
    int hash;
    for (int i = 0; i < HASH_RANGE; i++)
        hash = ML_hash(level + 1, n->keys[i]        
        child = n->children[hash]
        if child == NULL
            //allocate the child
            new_children++            
        //copy key and value to child
    increment widths[] value according to level and new_children

int MLH_delete(key)
    subtree_delete @ root.
int MLH_insert
    subtree_insert @ root.
int MLH_get
    subtree_get @ root.
    
subtree_delete
    If leaf (size <= HASH_RANGE),
        If desired key is in this node, remove the key and its value.
            Be sure to delete the data attached to the key (it's in static memory)
            To keep all values to the left of the node's array, take the last value and put it in the index we just deleted
            Decrement size of node
            If node empty, delete it--UNLESS IT'S THE ROOT NODE (decrement widths[] accordingly). Set children[]
                pointer of parent to NULL.
        If desired key is not in this node, return error.
    If stem,
        Call subtree_delete on the appropriate child (determined by hash function)--unless that child doesn't exist,
            in which case return error.
        Decrement size if the above call indicates that a deletion occurred.
            If size is now < HASH_RANGE, collapse.

void collapse(Node* n, int level) // collapsing children into n
    // for every non-null child of n
        // copy keys and data to parent
        // delete/deallocate that child NODE (not its data)
    // keep track of # deleted children, decrement widths[] corresponding value by that amount
    // set all of n's children[] pointers to NULL


